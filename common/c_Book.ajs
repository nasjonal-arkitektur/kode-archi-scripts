/*
 * c_Book
 */
 
load(__DIR__ + "Constants.ajs");
load(__DIR__ + "c_Model.ajs");
load(__DIR__ + "c_BookSection.ajs");

function cBook_autodoc(bookElement, sectionLevel) {

	if (!bookElement)
		lib_Error("No element selected?");


	var book = bookElement.concept;
	var docString = "";
	

	console.log("Top level element: " + book.name + " (" +  book.prop(const_prop_dct_type) + ")" );

	if (book.prop(const_prop_dct_type) != const_conceptType_representation__book) {
		window.alert("Problem: Expected top level element of dct:type=" +  const_conceptType_representation__book + ". Exiting...");
		exit();
	}


	// generate book header
	docString += cBook_bookHeader(book);
	
	// front cover
	if (book.prop(const_prop_book_front_cover_image) ) { 
		docString += "\n" + "image:" + const_imagepath_variable + book.prop(const_prop_book_front_cover_image) + "[]" + "\n\n";
	}
	
	
	// Include a first section with the documenation of the book object, if not empty
	docString += cBook_aboutBookChapter(book, sectionLevel);

	//determine first section
	var firstSection = cBook_determineFirstSection(book);
	//console.log("cBook_autodoc: First secton is " + firstSection.name);
	
	if (firstSection) {
		// starting with the first section, recursively drill down the hierarchy, go to next sibling section and so on
		//docString += cBookSection_autodoc(firstSection, sectionLevel);
		
		var nextSiblingSection = firstSection;
		docString += ":leveloffset: +1" + "\n";
		while (nextSiblingSection) {
			
			//docString += "=" + " " + nextSiblingSection.name + "\n"; // note: hardcoded top level sectionLevel!!!!!!!!!!!!!!!!!!!
			docString += cBookSection_IncludeSubsection(book, nextSiblingSection);
			
			cBookSection_autodoc(nextSiblingSection, sectionLevel + 1);	
			nextSiblingSection = cBookSection_nextSiblingSection(nextSiblingSection);
			
			
		}
		docString += ":leveloffset: -1" + "\n";
	}
	
	// back cover
	if (book.prop(const_prop_book_back_cover_image) ) {
		
		// {imagepath} variable may need to be reset poroperly here
		docString += cAntoraModule_imagePathString(book.name, cBookSection_getAntoraModule(book), 
															 cBookSection_getAntoraComponent(book), 
															 cBookSection_getAntoraVersion(book));
															 
		docString += "\n" + "image:" + const_imagepath_variable + book.prop(const_prop_book_back_cover_image) + "[]"+ "\n\n";
	}
	
	
	// save asciidoc text
	var modulePath = CBookSection_determineModulePath(book);
	CBookSection_saveViewPageToFile(book, docString, modulePath);	
	
	
	
	// run custom antora update script
	
	var updateScriptPath = cBook_GetAntoraUpdateScriptPath(book); // e.g. "C:\\antora\\modelx-no\\modelx-no-playbook\\update.sh";
	var cmdLineApp = "C:\\Program Files\\Git\\git-bash.exe";

	//var dirPath = window.promptOpenDirectory({ title: "Open Folder", "/defaultPath" });
	//var dirPath = window.promptOpenDirectory({ title: "Open Folder", playBookDir });
	//lib_TestExit(dirPath);

	//$.child_process.exec(cmdLineApp, playBookDir + "\\" + updateScriptFileName);
	$.child_process.exec(cmdLineApp, updateScriptPath);

	var result = window.confirm("Update script running... Click OK here when completed in order to see the resulting site...");
	if (result) {
		//var filePath = window.promptOpenFile({ title: "Open Model", filterExtensions: ["*.archimate", "default.archimate"] });
		var webBrowserApp = "C:\\Program Files\\Google\\Chrome\\Application\\chrome.exe";
		//$.child_process.exec(webBrowserApp, "C:\\antora\\modelx-no\\output\\github-pages\\modelx-no.github.io\\index.html");
		$.child_process.exec(webBrowserApp, "https://modelx-no.github.io");	
	}
	



	
	
	return true; //??
}

function cBook_bookHeader(book) {

	var docString = "";
	docString += cAntoraModule_asciidocTemplateHeader(book.name, cBookSection_getAntoraModule(book), 
														cBookSection_getAntoraComponent(book), 
														cBookSection_getAntoraVersion(book));



	docString += "\n";

	
	return docString;
}

function cBook_aboutBookChapter(book, sectionLevel) {
	
	var docString ="";
		
	if (book.documentation.length() > 0) {	
		var headerString = "\n" + "==";
		
		/*
		var i;
		for (i = 0; i < sectionLevel; i++) {
			headerString += "=";
		}
		*/	
		docString += headerString + " "; 
		
		docString += "Om " + book.name;
		//docString += "Oversikt";
		// docString += " - " + book.name;
		docString += "\n";

		// book description
		docString += "\n";
		docString += book.documentation;
		docString += "\n\n";
	}
	
	return docString;
}


function cBook_determineFirstSection(book) {
	
	var firstSection = null;
	var determined = false;
	
	// get the views/sections of the book, as represented by Representation objects with property dct:type = modelx:section:
	var topChapters = null;
	//var bookSubElms = cElement_getSubElements(book);
	var bookSections = cConcept_getSubConcepts(book);


	if (bookSections === null) {
		lib_Warning("No sections in book " + book.name);
	}
	else {

		// Test output list of all sectons
		var test_output_all_sections = false;
		if (test_output_all_sections) {
			bookSections.each(function(s) {
				
				console.log("Book " + book.name + ", section " +  s.name);

			});
		}
		
		// determine which section comes first (assume only one)

		bookSections.each(function(section) {
			
			if (!determined) {
				//console.log("determine firstSection, considering section  " + section.name);
				
				var incomingAssociationRels = $(section).inRels("association-relationship").size(); // i.e. for now consider only association-relationship, but see below

				
				if (incomingAssociationRels == 0) { // i.e. no preceeding chapter at the same hierarchy level
					firstSection = section; // assume, but still need to check...
						
					bookSections.each(function(otherSection) {
						//if (section != otherSection && cConcept_isSubConceptOf(section, otherSection)) {
						if (cConcept_isSubConceptOf(section, otherSection)) {
							console.log(section + " is subsection of " + otherSection);
							firstSection = null;
						}
					});

					if (firstSection) {
						//console.log("cBook_determineFirstSection: First section is " + firstSection.name);
						determined = true;
						//return firstSection;
						
					}

				}
			}
		});
		
		if (!firstSection) {
			window.alert("Problem: Unable to determine which is the first section of book " + book.name + ". Exiting...");
			exit();
		}
	}
	
	return firstSection;
	
		
}


function cBook_GetAntoraUpdateScriptPath(book) {	

	if (!book.prop(const_prop_antoraUdateScript))
		lib_Error("Missing book property " + const_prop_antoraUdateScript);

	var path = book.prop(const_prop_antoraUdateScript);
	return path;
}