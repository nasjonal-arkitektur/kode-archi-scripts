load(__DIR__ + "../common/c_Concept.ajs");
load(__DIR__ + "../common/c_Selection.ajs");


console.show();
console.clear();
console.log("Fetch Github Repository ID");

// Replace with your GitHub Personal Access Token
var TOKEN = "--changed--"

// Function to send GraphQL requests to GitHub using Java's HttpURLConnection
function sendGraphQLRequest(query) {
    var URL = Java.type("java.net.URL");
    var HttpURLConnection = Java.type("java.net.HttpURLConnection");
    var OutputStreamWriter = Java.type("java.io.OutputStreamWriter");
    var BufferedReader = Java.type("java.io.BufferedReader");
    var InputStreamReader = Java.type("java.io.InputStreamReader");
    
    var url = new URL("https://api.github.com/graphql");
    var connection = HttpURLConnection.class.cast(url.openConnection());
    connection.setRequestMethod("POST");
    connection.setRequestProperty("Authorization", "Bearer " + TOKEN);
    connection.setRequestProperty("Content-Type", "application/json");
    connection.setDoOutput(true);
    
    var writer = new OutputStreamWriter(connection.getOutputStream());
    writer.write(JSON.stringify({ query: query }));
    writer.close();
    
    // Log the X-RateLimit-Remaining header
    var remainingRequests = connection.getHeaderField("X-RateLimit-Remaining");
    console.log("Remaining GitHub API requests: " + remainingRequests);
    
    var reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    var response = "";
    var line;
    while ((line = reader.readLine()) !== null) {
        response += line;
    }
    reader.close();
    
    return JSON.parse(response);
}

// Function to fetch the GitHub repository ID
function getRepositoryId() {
    var query = `
    {
      repository(owner: "erikhag1", name: "altinn-test-repo") {
        id
      }
    }
    `;
    var response = sendGraphQLRequest(query);
    return response.data.repository.id;
}

function CreateOrUpdateGithubIssueFromArchiConcept(epic) {
    // Fetch data from the Epic object
    var archiGUID = epic.id;
    var title = epic.name;

    // Build the issueBody according to the template
    var issueBody = "### Description\n\n";
    issueBody += epic.documentation ? epic.documentation.replace(/\n/g, "\\n") : "No description provided."; // Ensure there's always a description and replace newline characters

    issueBody += "\n\n### In scope\n\n_No response_";
    issueBody += "\n\n### Out of scope\n\n_No response_";
    issueBody += "\n\n### Additional Information\n";
    issueBody += "\n- **Archi Object ID**: " + archiGUID;

    // Fetch the GitHub repository ID
    var repoId = getRepositoryId();
    console.log("RepoId: " + repoId);

    // Build the GraphQL mutation to create an issue
    var mutation = `
      mutation {
        createIssue(input: {
          repositoryId: "${repoId}", 
          title: "${title}", 
          body: "${issueBody}",
          # Add more fields as needed...
        }) {
          issue {
            id
            title
            body
          }
        }
      }
    `;

    // Send the request
    var response = sendGraphQLRequest(mutation);

    // Check if the issue was created/updated successfully
    if (response.data && response.data.createIssue) {
        // Extract the issue's GraphQL ID (GUID)
        var issueGUID = response.data.createIssue.issue.id;

        // Store the issue's GUID as a property on the Archi object
        cConcept_SetProperty(epic, const_prop_githubIssueGUID, issueGUID);

        console.log("Issue created/updated successfully with ID:", issueGUID);
        
        // Update the issue with the GraphQL ID
        updateIssueWithGraphQLID(issueGUID, issueGUID, issueBody);
    } else {
        console.log("Error creating/updating the issue:", JSON.stringify(response.errors));
    }
}


function updateIssueWithGraphQLID(issueId, graphQLId, originalBody) {
    var updatedBody = originalBody + "\n- **GraphQL ID**: " + graphQLId;
	
    var query = `
    mutation {
      updateIssue(input: {
        id: "${issueId}",
        body: "${updatedBody}"
      }) {
        issue {
          id
          title
          body
        }
      }
    }
    `;

    return sendGraphQLRequest(query);
}

var dctConceptTypeFilter = window.prompt("dct:type concept type filter", "capability");
if (!dctConceptTypeFilter) 
	exit();

var selectedConcepts = CSelection_GetSelectedConcepts("", "", dctConceptTypeFilter);
if (!selectedConcepts)
	lib_Error("No concepts selected. Exiting...");

	
selectedConcepts.each(function(c) {
	
	console.log(c.name);
	

	// If the concept is a user story, first fix the documentation property
	//if (c.prop(const_prop_dct_type) === const_conceptType_goal__user_story) 
	//	cConcept_generateUserStoryDescription(c);

	var github_graphqlID = CreateOrUpdateGithubIssueFromArchiConcept(c);
	//updateIssueWithGraphQLID(github_graphqlID, github_graphqlID);



});	


console.log("Script completed");


