load(__DIR__ + "../common/c_Concept.ajs");
load(__DIR__ + "../common/c_Selection.ajs");

console.show();
console.clear();
console.log("Create or update Github issues");

var gh_repo_owner = "githagen"; var gh_repo_name = "altinn-test-repo";
//var gh_repo_owner = "erikhag1"; var gh_repo_name = "altinn-test-repo";
//var gh_repo_owner = "altinn"; var gh_repo_name = "testrepo-melding-formidling";
var createdCount = 0;
var updatedCount = 0;


var TOKEN = java.lang.System.getenv("MY_PAT"); // all of erikhag1 owned repos
//var TOKEN = java.lang.System.getenv("eriks_altinn_testrepo_pat"); // altinn owned testrepo-melding-formidling
//console.log("Token Length: " + (TOKEN ? TOKEN.length : "Token is null"));

function fetchLabels() {
    //see global var: var gh_repo_owner = "githagen"; // Erstatt med ditt brukernavn
    //see global var:var gh_repo_name = "altinn-test-repo"; // Erstatt med ditt repositoriums navn

    var query = `
    {
      repository(owner: "${gh_repo_owner}", name: "${gh_repo_name}") {
        labels(first: 100) {
          nodes {
            id
            name
          }
        }
      }
    }
    `;

    var response = sendGraphQLRequest(query);
    if (response.data && response.data.repository && response.data.repository.labels) {
        return response.data.repository.labels.nodes;
    } else {
        console.error("Failed to fetch labels:", response);
        return [];
    }
}

function fetchLabelIdByName(labelName) {

    var query = `
    {
      repository(owner: "${gh_repo_owner}", name: "${gh_repo_name}") {
        label(name: "${labelName}") {
          id
        }
      }
    }
    `;

    var response = sendGraphQLRequest(query);
    if (response.data && response.data.repository && response.data.repository.label) {
        return response.data.repository.label.id;
    } else {
        console.error("Failed to fetch label ID:", response);
        return null;
    }
}

function getRateLimits(doLogResult) {
    var URL = Java.type("java.net.URL");
    var HttpURLConnection = Java.type("java.net.HttpURLConnection");
    var OutputStreamWriter = Java.type("java.io.OutputStreamWriter");
    var BufferedReader = Java.type("java.io.BufferedReader");
    var InputStreamReader = Java.type("java.io.InputStreamReader");
    
    var url = new URL("https://api.github.com/graphql");
    var connection = HttpURLConnection.class.cast(url.openConnection());
    connection.setRequestMethod("POST");
    connection.setRequestProperty("Authorization", "Bearer " + TOKEN);
    connection.setRequestProperty("Content-Type", "application/json");
    connection.setDoOutput(true);
    
    // Send a simple GraphQL query to get the viewer's login (just as a placeholder query)
    var writer = new OutputStreamWriter(connection.getOutputStream());
    writer.write(JSON.stringify({ query: "{ viewer { login } }" }));
    writer.close();

    var reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    var response = "";
    var line;
    while ((line = reader.readLine()) !== null) {
        response += line;
    }
    reader.close();

    var result =  {
        remaining: connection.getHeaderField("X-RateLimit-Remaining"),
        reset: new Date(parseInt(connection.getHeaderField("X-RateLimit-Reset")) * 1000).toLocaleString()
    };
	
	if (doLogResult) {
		console.log("GitHub API requests remaining: " + result.remaining);
		console.log("Rate limit will be reset at: " + result.reset);
	}
	
	return result;
}

function isIssueOpen(issueId) {
    var query = `
    {
      repository(owner: "${gh_repo_owner}", name: "${gh_repo_name}") {
        issue(number: ${issueId}) {
          state
        }
      }
    }
    `;

    var response = sendGraphQLRequest(query);
    if (response.data && response.data.repository && response.data.repository.issue) {
        return response.data.repository.issue.state === "OPEN";
    } else {
        console.error("Failed to fetch issue state:", response);
        return false;
    }
}

function getOpenIssue(issueId) {
    var query = `
    {
      node(id: "${issueId}") {
        ... on Issue {
          id
          state
          title
          body
        }
      }
    }
    `;

    var response = sendGraphQLRequest(query);
    if (response.data && response.data.node && response.data.node.state) {
        return response.data.node.state === "OPEN" ? response.data.node : null;
    } else {
        lib_Error("Failed to fetch issue status: " + JSON.stringify(response));
        return null;
    }
}

function sendGraphQLRequest(query) {
    var URL = Java.type("java.net.URL");
    var HttpURLConnection = Java.type("java.net.HttpURLConnection");
    var OutputStreamWriter = Java.type("java.io.OutputStreamWriter");
    var BufferedReader = Java.type("java.io.BufferedReader");
    var InputStreamReader = Java.type("java.io.InputStreamReader");
    
    var url = new URL("https://api.github.com/graphql");
    var connection = HttpURLConnection.class.cast(url.openConnection());
    connection.setRequestMethod("POST");
    connection.setRequestProperty("Authorization", "Bearer " + TOKEN);
    connection.setRequestProperty("Content-Type", "application/json");
    connection.setDoOutput(true);
    
    var writer = new OutputStreamWriter(connection.getOutputStream());
    writer.write(JSON.stringify({ query: query }));
    writer.close();

    var reader = new BufferedReader(new InputStreamReader(connection.getInputStream()));
    var response = "";
    var line;
    while ((line = reader.readLine()) !== null) {
        response += line;
    }
    reader.close();

    // Log the GraphQL rate limit remaining
	//var rateLimits = getRateLimits();
	//console.log("GitHub API requests remaining: " + rateLimits.remaining);
	//console.log("Rate limit will be reset at: " + rateLimits.reset);

    return JSON.parse(response);
}



var query = `
{
  repository(owner: "${gh_repo_owner}", name: "${gh_repo_name}") {
    id
    name
  }
}`;

var response = sendGraphQLRequest(query).data.repository;
var repoId = response.id;
var fetchedRepoName = response.name;

console.log("Fetched repository name:", fetchedRepoName);
console.log("RepoId: " + repoId);




function CreateOrUpdateGithubIssueFromArchiConcept(ghIssue) {
    var archiGUID = ghIssue.id;
    var existingGHGuid = cConcept_GetProperty(ghIssue, const_prop_githubIssueGUID);
	var openIssue = existingGHGuid ? getOpenIssue(existingGHGuid) : null;

    var title = ghIssue.name.replace(/"/g, '\\"'); 
    var issueBody = "### Description\n\n";
    issueBody += ghIssue.documentation ? ghIssue.documentation.replace(/\n/g, "\\n").replace(/"/g, '\\"') : "No description provided."; 
    issueBody += "\n\n### Tasks\n";
    issueBody += "\n- [x] Completed task\n";
    issueBody += "\n- [ ] Incompleted task";
    issueBody += "\n\n### Additional Information\n";
    issueBody += "\n- **Archi Object ID**: " + archiGUID;
    if (existingGHGuid) issueBody += "\n- **GraphQL ID**: " + existingGHGuid;

    var mutation;
	if (openIssue) {
		// Oppdater eksisterende åpent issue
		updatedCount++;
		mutation = `
		mutation {
		  updateIssue(input: {
			id: "${existingGHGuid}",
			title: "${title}",
			body: "${issueBody}"
		  }) {
			issue {
			  id
			  title
			  body
			}
		  }
		}
		`;
	} else {
		// Opprett nytt issue (enten fordi det ikke finnes et eksisterende issue, eller fordi det eksisterende issuet er lukket)
		createdCount++;
		mutation = `
		mutation {
		  createIssue(input: {
			repositoryId: "${repoId}", 
			title: "${title}", 
			body: "${issueBody}",
		  }) {
			issue {
			  id
			  title
			  body
			}
		  }
		}
		`;
	}


    var response = sendGraphQLRequest(mutation);
 

	var needToWait = true;
	var i = 0;
	var secondsToWait = 65;
	var timesToRetry = 2;
	while (needToWait) {
		if (response.errors && response.errors[0].message === "was submitted too quickly") {
			
		
			console.log("Rate limit hit, assuming per minute request limit (of 20?), so waiting " + secondsToWait + " seconds...");
			var rateLimits = getRateLimits(true);
			java.lang.Thread.sleep(secondsToWait * 1000);
			// Retry the request
			response = sendGraphQLRequest(mutation);
		}
		else
			needToWait = false;
			
		if (i++ > timesToRetry)
			lib_Error("Retried sendGraphQLRequest to github several times. Consider increasing the secondsToWait value in the script?");
	}

	console.log("Evaluating response conditions...");
	if (response.data) {
		console.log("Checking if issue should be updated...");
		console.log("Value of existingGHGuid:", existingGHGuid);
		if (existingGHGuid && response.data.updateIssue && response.data.updateIssue.issue) {
			var issueGUID = response.data.updateIssue.issue.id;
			cConcept_SetProperty(ghIssue, const_prop_githubIssueGUID, issueGUID);
			console.log("Issue with ID:" + issueGUID +  " successfully updated");
		} 
		else {
			console.log("Checking if a new issue should be created...");
			if (!existingGHGuid && response.data.createIssue && response.data.createIssue.issue) {
				var issueGUID = response.data.createIssue.issue.id;
				updateIssueWithGraphQLID(issueGUID, issueGUID, issueBody);
				console.log("Issue created successfully with ID:", issueGUID);
			} 
			else {
				console.log("Unexpected response structure:", JSON.stringify(response, null, 2));
				if (response.errors && response.errors.length > 0) {
					console.error("Errors from GitHub:", JSON.stringify(response.errors, null, 2));
				}
				lib_Error("Script aborting due to unexpected error");
			}
		}
	}

	
}



function updateIssueWithGraphQLID(issueId, graphQLId, originalBody) {
    var updatedBody = originalBody + "\n- **GraphQL ID**: " + graphQLId;
	

    var query = `
    mutation {
      updateIssue(input: {
        id: "${issueId}",
        body: "${updatedBody}"
      }) {
        issue {
          id
          title
          body
        }
      }
    }
    `;

    return sendGraphQLRequest(query);
}


function processConcepts(concepts) {
    for (let i = 0; i < concepts.length; i++) {
        console.log("\nConcept name: " + concepts[i].name);
        CreateOrUpdateGithubIssueFromArchiConcept(concepts[i]);
    }
}

var dctConceptTypeFilter = window.prompt("dct:type concept type filter", "epic");
if (!dctConceptTypeFilter) {
	let confirmed = window.confirm("Proceed to process all selected elements without filtering on dct:type?");
	if (!confirmed)
		lib_Error("Cancelled by user. Exiting...");;
}


function ghLabelsexperiment() {
	
	var labels = fetchLabels();
	//console.log("All labels: \n\n"+ JSON.stringify(labels, null, 2));
	
	
	var labelName = "bug"; // Erstatt med navnet på labelen du vil hente
	var labelId = fetchLabelIdByName(labelName);
	console.log("Requested labelId: ", labelId);

}
//ghLabelsexperiment();
//lib_TestExit("Exiting after experiment...");




var selectedConcepts = CSelection_GetSelectedConcepts("", "", dctConceptTypeFilter);
if (!selectedConcepts || selectedConcepts.size() === 0)
	lib_Error("No concepts selected. Hint: Check dct:type property. Exiting...");

console.log("Processing " + selectedConcepts.length + "concepts...");
processConcepts(selectedConcepts);
console.log("Processed " + selectedConcepts.length + "concepts");
console.log("Created " + createdCount + " new isssues and updated " + updatedCount + " existing issues");



// Log the final rate limits
var finalRateLimits = getRateLimits(true);
//console.log("GitHub API requests remaining: " + finalRateLimits.remaining);
//console.log("Rate limit will be reset at: " + finalRateLimits.reset);


console.log("Script completed");